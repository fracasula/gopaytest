package routes

import (
	"encoding/json"
	"fmt"
	"gopaytest/models/payment"
	repository "gopaytest/repositories/payments"
	"gopaytest/uuid"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/go-chi/chi"
	"github.com/go-chi/render"
)

// NewPaymentsRouter returns a router with the payments routes attached
func NewPaymentsRouter(paymentsRepository repository.Repository, logger *log.Logger) *chi.Mux {
	router := chi.NewRouter()
	payments := &paymentsRouter{
		paymentsRepository: paymentsRepository,
		logger:             logger,
	}

	router.Get("/", payments.GetPayments)
	router.Get("/{paymentId}", payments.GetPayment)
	router.Post("/", payments.CreatePayment)
	router.Put("/{paymentId}", payments.UpdatePayment)
	router.Delete("/{paymentId}", payments.DeletePayment)

	return router
}

type paymentsRouter struct {
	paymentsRepository repository.Repository
	logger             *log.Logger
}

func (pr *paymentsRouter) GetPayments(w http.ResponseWriter, r *http.Request) {
	count, err := pr.paymentsRepository.CountPayments()
	if err != nil {
		go pr.logger.Printf("Could not get payments count: %v", err)
		RenderError(w, r, "Could not get payments count", http.StatusInternalServerError)
		return
	}

	payments := make([]payment.Payment, 0)
	pageSize, pageNumber, offset := With(r).PageValues()

	if count > 0 {
		payments, err = pr.paymentsRepository.GetPayments(pageSize, offset)
		if err != nil {
			go pr.logger.Printf("Could not get payments list: %v", err)
			RenderError(w, r, "Could not get payments list", http.StatusInternalServerError)
			return
		}
	}

	page := &paymentsPage{
		Data: payments,
		Links: pageLinks{
			Self: With(r).SelfLink(),
		},
	}

	WritePaginationHeaders(w, pageSize, pageNumber, count)
	render.JSON(w, r, page)
}

func (pr *paymentsRouter) GetPayment(w http.ResponseWriter, r *http.Request) {
	paymentID := chi.URLParam(r, "paymentId")
	if !uuid.IsValidUUID(paymentID) {
		RenderError(w, r, "Invalid payment ID supplied, must be a valid UUID", http.StatusBadRequest)
		return
	}

	entity, err := pr.paymentsRepository.GetPayment(paymentID)
	if err != nil {
		msg := fmt.Sprintf("Could not get payment with ID %q", paymentID)
		go pr.logger.Printf("%s: %v", msg, err)
		RenderError(w, r, msg, http.StatusInternalServerError)
		return
	}

	if entity == nil {
		RenderError(w, r, fmt.Sprintf("Could not find payment with ID %q", paymentID), http.StatusNotFound)
		return
	}

	render.JSON(w, r, &paymentPage{
		Data: *entity,
		Links: pageLinks{
			Self: With(r).SelfLink(),
		},
	})
}

func (pr *paymentsRouter) CreatePayment(w http.ResponseWriter, r *http.Request) {
	jsonData, err := ioutil.ReadAll(r.Body)
	if err != nil {
		RenderError(w, r, "Invalid request body", http.StatusBadRequest)
		return
	}

	var p payment.Payment
	if err := json.Unmarshal(jsonData, &p); err != nil {
		RenderError(w, r, "Request body is not a valid Payment", http.StatusBadRequest)
		return
	}

	if p.ID != "" {
		RenderError(w, r, "Payment ID is autogenerated, please leave it empty", http.StatusBadRequest)
		return
	}

	if p.Version != 0 {
		RenderError(w, r, "Payment version is autogenerated, please leave it empty", http.StatusBadRequest)
		return
	}

	p.ID = uuid.NewV4String()
	p.Version = 1

	if err := pr.paymentsRepository.CreatePayment(p); err != nil {
		go pr.logger.Printf("Could not create new payment: %v", err)
		RenderError(w, r, "Could not create new payment", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Location", With(r).SelfLink()+"/"+p.ID)
	render.Status(r, http.StatusCreated)
	render.JSON(w, r, &paymentPage{
		Data: p,
		Links: pageLinks{
			Self: With(r).SelfLink() + "/" + p.ID,
		},
	})
}

func (pr *paymentsRouter) UpdatePayment(w http.ResponseWriter, r *http.Request) {
	jsonData, err := ioutil.ReadAll(r.Body)
	if err != nil {
		RenderError(w, r, "Invalid request body", http.StatusBadRequest)
		return
	}

	var p payment.Payment
	if err := json.Unmarshal(jsonData, &p); err != nil {
		RenderError(w, r, "Request body is not a valid Payment", http.StatusBadRequest)
		return
	}

	if p.ID != "" {
		RenderError(w, r, "Payment ID is autogenerated, please leave it empty", http.StatusBadRequest)
		return
	}

	paymentID := chi.URLParam(r, "paymentId")
	if !uuid.IsValidUUID(paymentID) {
		RenderError(w, r, "Invalid payment ID supplied, must be a valid UUID", http.StatusBadRequest)
		return
	}

	p.ID = paymentID
	ok, updateErr := pr.paymentsRepository.UpdatePayment(p)
	if updateErr != nil {
		msg := fmt.Sprintf("Could not update payment with ID %q", paymentID)
		go pr.logger.Printf("%s: %v", msg, updateErr)

		if updateErr.IsConflict() {
			RenderError(w, r, msg, http.StatusConflict)
		} else {
			RenderError(w, r, msg, http.StatusInternalServerError)
		}

		return
	}

	if !ok {
		RenderError(w, r, fmt.Sprintf("Could not find payment with ID %q", paymentID), http.StatusNotFound)
		return
	}

	updatedPayment, err := pr.paymentsRepository.GetPayment(paymentID)
	if err != nil {
		msg := fmt.Sprintf("Could not get payment with ID %q", paymentID)
		go pr.logger.Printf("%s: %v", msg, err)
		RenderError(w, r, msg, http.StatusInternalServerError)
		return
	}

	if updatedPayment == nil {
		// a delete could have been taken place before we could return our response
		RenderError(w, r, fmt.Sprintf("Could not find payment with ID %q", paymentID), http.StatusNotFound)
		return
	}

	render.Status(r, http.StatusOK)
	render.JSON(w, r, &paymentPage{
		Data: *updatedPayment,
		Links: pageLinks{
			Self: With(r).SelfLink(),
		},
	})
}

func (pr *paymentsRouter) DeletePayment(w http.ResponseWriter, r *http.Request) {
	paymentID := chi.URLParam(r, "paymentId")
	if !uuid.IsValidUUID(paymentID) {
		RenderError(w, r, "Invalid payment ID supplied, must be a valid UUID", http.StatusBadRequest)
		return
	}

	ok, err := pr.paymentsRepository.DeletePayment(paymentID)
	if err != nil {
		msg := fmt.Sprintf("Could not delete payment with ID %q", paymentID)
		go pr.logger.Printf("%s: %v", msg, err)
		RenderError(w, r, msg, http.StatusInternalServerError)
		return
	}

	if !ok {
		RenderError(w, r, fmt.Sprintf("Could not find payment with ID %q", paymentID), http.StatusNotFound)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

type paymentPage struct {
	Data  payment.Payment `json:"data"`
	Links pageLinks       `json:"links"`
}

type paymentsPage struct {
	Data  []payment.Payment `json:"data"`
	Links pageLinks         `json:"links"`
}

type pageLinks struct {
	Self string `json:"self"`
}
